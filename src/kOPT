

#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;

//prepsat 0 a 1 na bool


struct Node
{
	int positionX;
	int positionY;
	Node* firstNeighbour;
	Node* secondNeighbour;
};


//dealokovat!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
class CircularLinkedList
{
    public:
		CircularLinkedList()
		{
			startNode = NULL;
			listLength = 0;
		}
		
		void InsertNode(int positionX, int positionY)
		{
			if (listLength == 0)
			{
				startNode = new Node();
				
				startNode->positionX = positionX;
				startNode->positionY = positionY;
				startNode->firstNeighbour = startNode;
				startNode->secondNeighbour = startNode;
			}
			else if (listLength == 1)
			{
				Node* newNode = new Node();		
				newNode->positionX = positionX;
				newNode->positionY = positionY;
				newNode->firstNeighbour = startNode;
				newNode->secondNeighbour = startNode;
				
				startNode->firstNeighbour = newNode;
				startNode->secondNeighbour = newNode;
			}
			else
			{
				Node* tmpSecondNeighbour = startNode->secondNeighbour;
				
				Node* newNode = new Node();		
				newNode->positionX = positionX;
				newNode->positionY = positionY;
				newNode->firstNeighbour = startNode;
				newNode->secondNeighbour = tmpSecondNeighbour;
				
				startNode->secondNeighbour = newNode;
				tmpSecondNeighbour->firstNeighbour = newNode;
				
			}
			
			listLength++;
		}
		
		void GetStartNode (Node** startNode, Node** previousNode)
		{
			*startNode = this->startNode;
			*previousNode = this->startNode->secondNeighbour;
		}
		
		void GetNextNode (Node** currentNode, Node** previousNode)
		{
			if ((*currentNode)->firstNeighbour == *previousNode)
			{
				*previousNode = *currentNode;
				*currentNode = (*currentNode)->secondNeighbour;
			}
			else
			{
				*previousNode = *currentNode;
				*currentNode = (*currentNode)->firstNeighbour;
			}
		}
		
		void PerformNOptSwap (vector<Node*> &swapNodes, vector<Node*> &swapNodesPredecessors, vector<int> &permutation)
		{
			unsigned int i;
			
			for (i = 0; i < swapNodes.size()-1; i++)
			{
				std::cout << "|" << swapNodes.at(i)->positionX << ", " << swapNodes.at(i)->positionY << "|" << " -- ";
			}
			
			std::cout << "|" << swapNodes.at(i)->positionX << ", " << swapNodes.at(i)->positionY << "|" << "\n";

			
			
			/*
		    std::cout << swapNodes.at(0)->positionX << ", " << swapNodes.at(0)->positionY << " -- ";
			std::cout << swapNodes.at(1)->positionX << ", " << swapNodes.at(1)->positionY << " -- ";
			std::cout << swapNodes.at(2)->positionX << ", " << swapNodes.at(2)->positionY << " -- ";
			std::cout << swapNodes.at(3)->positionX << ", " << swapNodes.at(3)->positionY << " -- ";
			std::cout << swapNodes.at(4)->positionX << ", " << swapNodes.at(4)->positionY << " -- ";
			std::cout << swapNodes.at(5)->positionX << ", " << swapNodes.at(5)->positionY << "\n";
			*/
			
			
			
		}
		
		void DisplayList ()
		{
			Node* startNode = NULL;
			Node* currentNode = NULL;
			Node* previousNode = NULL;
			
			GetStartNode(&currentNode, &previousNode);
			startNode = currentNode;
			
			std::cout << "\n";
			DisplayNode(currentNode);		
			GetNextNode (&currentNode, &previousNode);
				
			while (currentNode != startNode)
			{
				DisplayNode(currentNode);
				GetNextNode (&currentNode, &previousNode);			
			}
			
			std::cout << "\n";
		}
	
		int GetLength()
		{
			return listLength;
		}
		
    private:
		Node* startNode;
		int listLength;
		
		void DisplayNode(Node* node)
		{
			std::cout << "[" << node->positionX << ", " << node->positionY << "]" << "\n";
		}	
};



void VectorDeepCopy (vector<int> &destination, vector<int> &source)
{
	unsigned int sourceSize = source.size();
	destination.resize(sourceSize); 
	
	for (unsigned int i = 0; i < sourceSize; i++)
	{
		destination.at(i) = source.at(i);
	}
}


class PermutationGenerator
{
	public:
		PermutationGenerator(vector<int> &symbolArray)
		{
			this->symbolArray = symbolArray;
			
			VectorDeepCopy(this->symbolArrayCopy, symbolArray);
			this->symbolArraySize = this->symbolArrayCopy.size();	
			
			for (int i = 0; i < this->symbolArraySize; i++) 
			{
				this->stack.push_back(0);
			}
			
			this->state  = 0;
			this->permutationI = 0;
		}
	
		//smazat
		void TestPrint()
		{
			std::cout << "Test: " << symbolArray.at(5) << "\n";
		}
		
		//https://en.wikipedia.org/wiki/Heap%27s_algorithm
		int ReturnNextPermutation(vector<int> &permutation)
		{			
			if (state == 1)
			{
				goto STATE1;
			}
			else if (state == 2)
			{
				goto STATE2;
			}
			else if (state == 3)
			{
				return 3;
			}
			
			state = 1;
			VectorDeepCopy(permutation, symbolArrayCopy);
			return 1;
			STATE1:
			
			while (permutationI < symbolArraySize)
			{
				if (stack[permutationI] < permutationI)
				{
					if (permutationI % 2 == 0) 
					{ 
						SwapInts(&(symbolArrayCopy.at(0)), &(symbolArrayCopy.at(permutationI)));
					} 
					else
					{
						SwapInts(&(symbolArrayCopy.at(stack[permutationI])), &(symbolArrayCopy.at(permutationI)));
					}
					
					state = 2;
					VectorDeepCopy(permutation, symbolArrayCopy);
					return 2;
					STATE2:

					stack[permutationI]++;
					permutationI = 0;
				}
				else
				{
					stack[permutationI] = 0;
					permutationI++;
				}
			}
			
			state = 3;
			return 3;
		}
	
	private:
		vector<int> symbolArray;
		
		vector<int> symbolArrayCopy;
		int symbolArraySize;
		vector<int> stack;
		
		int state;
		int permutationI;
			
		void SwapInts (int* firstInt, int* secondInt)
		{
			int tmp = *firstInt;
			*firstInt = *secondInt;
			*secondInt = tmp;
		}
		
		/*
		int Factorial(int n)
		{
			int result = 1;
			
			for (int i = 0; i < n; i++)
			{
				result = result * i;
			}
			
			return result;
		}
		*/
};

/*
int AreCircularSequencesRotationsOfEachOther (vector<int> firstSequence, vector<int> secondSequence)
{
	int SequencesSize = firstSequence.size();
	int matchLength;
	
	for (int i = 0; i < SequencesSize; i++)
	{
		matchLength = 0;
		
		for (int j = 0; j < SequencesSize; j++)
		{
			//std::cout << firstSequence.at(j) << ", " << secondSequence.at((i+j)%SequencesSize) <<"\n";
			
			if (firstSequence.at(j) == secondSequence.at((i+j)%SequencesSize))
			{
				matchLength++;
			}
			else
			{
				break;
			}
		}
		
		if (matchLength == SequencesSize)
		{
			return 1;
		}
	}
	
	return 0;
}*/

//druha musi byt mensi
bool DoesCircularSequenceContainsSubsequence(vector<int> &firstSequence, vector<int> &secondSequence)
{
	int firstSequenceSize = firstSequence.size();
	int secondSequenceSize = secondSequence.size();
	int matchLength;
	
	for (int i = 0; i < firstSequenceSize; i++)
	{	
		matchLength = 0;

		for (int j = 0; j < secondSequenceSize; j++)
		{
			if (firstSequence.at((i+j)%firstSequenceSize) == secondSequence.at(j))
			{
				matchLength++;
			}
			else
			{
				break;
			}
		}
		
		if (matchLength == secondSequenceSize)
		{
			return true;
		}
	}
	
	return false;
}

bool DoesSequenceContainsRequiredConnections(vector<int> &sequence)
{
	int sequenceSize = sequence.size();
	int numberOfRequiredConnections = sequenceSize/2;
	
	vector<int> actConnection;
	vector<int> actConnectionReversed;
		
	for (int i = 1; i <= numberOfRequiredConnections; i++)
	{
		actConnection.push_back(i*2);
		actConnection.push_back((i*2+1)%sequenceSize);
		
		actConnectionReversed.push_back((i*2+1)%sequenceSize);
		actConnectionReversed.push_back(i*2);
		
		if (DoesCircularSequenceContainsSubsequence(sequence, actConnection) == false && DoesCircularSequenceContainsSubsequence(sequence, actConnectionReversed) == false)
		{
			return false;
		}
			
		actConnection.clear();
		actConnectionReversed.clear();
	}
	
	return true;
}



void GenerateAllValidSwaps(vector<vector<int>> &validPermutations, int k)
{
	//startovni bod bude vzydcky jednicka a pak pet nahodnych napojeni
	int permutationLength = k*2-1;
	
	vector<int> symbolArray;
	
	for (int i = 0; i < permutationLength; i++)
	{
		symbolArray.push_back(i+2);
	}
	
	PermutationGenerator permutationGenerator(symbolArray);


	vector<int> actPermutation;
	vector<int> actPermutationReversed;
	
	int retValue = permutationGenerator.ReturnNextPermutation(actPermutation);
	bool safeToAdd;
	
	//3 znamena, ye uz  nejsou k dispozici dalsi
	while(retValue != 3)
	{
		//fixnuta 1, nejsou rotace
		actPermutation.push_back(1);
		
		/*
		for (unsigned int i = 0; i < actPermutation.size(); i++)
		{
			std::cout << actPermutation.at(i);	
		}
		std::cout << "\n";*/
		
		if (DoesSequenceContainsRequiredConnections(actPermutation) == true)
		{
			safeToAdd = true;
			
			VectorDeepCopy(actPermutationReversed, actPermutation);
			reverse(actPermutationReversed.begin(), actPermutationReversed.end()); 
			
			for (unsigned int i = 0; i < validPermutations.size(); i++)
			{
				if (DoesCircularSequenceContainsSubsequence(actPermutationReversed, validPermutations.at(i)) == true)
				{
					safeToAdd = false;
					break;
				}
			}
			
			if (safeToAdd == true)
			{	
				validPermutations.push_back(actPermutation);
			}
		}

		retValue = permutationGenerator.ReturnNextPermutation(actPermutation);
	}

	std::cout << "\n";
	for (unsigned int i = 0; i < validPermutations.size(); i++)
	{
		for (unsigned int j = 0; j < validPermutations.at(i).size(); j++)
		{
			std::cout << validPermutations.at(i).at(j);	
		}
		std::cout << "\n";
	}
}
void InitNestedLoop(CircularLinkedList* graph, vector<Node*> &swapNodes, vector<Node*> &swapNodesPredecessors, vector<int> &swapNodesPosition, int loopLevel)
{	
	int firstNodeIndex = loopLevel*2;
	int secondNodeIndex = loopLevel*2+1;
	
	int previousLoopOffset = -2;
	
	if (loopLevel == 0)
	{
		swapNodesPosition.at(loopLevel) = 0;
		
		graph->GetStartNode(&(swapNodes.at(firstNodeIndex)), &(swapNodesPredecessors.at(firstNodeIndex)));
		graph->GetStartNode(&(swapNodes.at(secondNodeIndex)), &(swapNodesPredecessors.at(secondNodeIndex)));
	
		graph->GetNextNode(&(swapNodes.at(secondNodeIndex)), &(swapNodesPredecessors.at(secondNodeIndex)));
	}
	else
	{
		//hodnota predchoziho cyklu + offset, ktery je 2
		swapNodesPosition.at(loopLevel) = swapNodesPosition.at(loopLevel-1) + 2;
		
		swapNodes.at(firstNodeIndex) = swapNodes.at(firstNodeIndex + previousLoopOffset);
		swapNodes.at(secondNodeIndex) = swapNodes.at(secondNodeIndex + previousLoopOffset);
		
		swapNodesPredecessors.at(firstNodeIndex) = swapNodesPredecessors.at(firstNodeIndex + previousLoopOffset);
		swapNodesPredecessors.at(secondNodeIndex) = swapNodesPredecessors.at(secondNodeIndex + previousLoopOffset);
		
		graph->GetNextNode(&(swapNodes.at(firstNodeIndex)), &(swapNodesPredecessors.at(firstNodeIndex)));
		graph->GetNextNode(&(swapNodes.at(firstNodeIndex)), &(swapNodesPredecessors.at(firstNodeIndex)));
		
		graph->GetNextNode(&(swapNodes.at(secondNodeIndex)), &(swapNodesPredecessors.at(secondNodeIndex)));
		graph->GetNextNode(&(swapNodes.at(secondNodeIndex)), &(swapNodesPredecessors.at(secondNodeIndex)));
	}
}


// int GetNextPermutationSymbol (int symbol, vector<int> &permutation)
// {
	// int i = 0;
	
	// while (permutation.at(i) != symbol)
	// {
		// i++;
	// }
	
	// return permutation.at((i+1)%permutation.size());
// }

double CalculateEuclidianDistanceBetweenTwoNodes(Node* firstNode, Node* secondNode)
{
	return hypot(secondNode->positionX-firstNode->positionX, secondNode->positionY-firstNode->positionY);
}

//permutace konci jednickou, coz je zacatek pak se jde normalne po dvojicich
bool IsReconnectionShorter (vector<Node*> &swapNodes ,vector<int> &permutation, double currentPathLength)
{
	double reconnectedPathLength = 0;
	int size = swapNodes.size();

	for (int i = size; i < size+size; i+=2)
	{
		// std::cout << permutation.at((i-1)%size)-1 << "\n";
		// std::cout << permutation.at((i)%size)-1 << "\n\n";
		reconnectedPathLength += CalculateEuclidianDistanceBetweenTwoNodes(swapNodes.at(permutation.at((i-1)%size)-1), swapNodes.at(permutation.at((i)%size)-1));
	}
	
	std::cout << reconnectedPathLength << "\n";
	
	if (reconnectedPathLength < currentPathLength)
	{
		return true;
	}
	else
	{
		return false;
	}
}



bool TryAllSwapsForCurrentEdgeCombination (vector<Node*> &swapNodes, vector<Node*> &swapNodesPredecessors, vector<vector<int>> &validPermutations)
{
	double currentPathLength = 0;
	
	for (unsigned int i = 0; i < swapNodes.size(); i+=2)
	{
		currentPathLength += CalculateEuclidianDistanceBetweenTwoNodes(swapNodes.at(i), swapNodes.at(i+1));
	}
	
	
	
	std::cout << currentPathLength << "\n";
	
	for (unsigned int i = 0; i < validPermutations.size(); i++)
	{	
		if (IsReconnectionShorter (swapNodes, validPermutations.at(i), currentPathLength) == true)
		{
			//swap
			return true;
		}
	}
	
	
	
	// for (i)
	// graph.PerformNOptSwap(swapNodes, swapNodesPredecessors, validPermutations.at(1));

	return false;
}


int main(int argc, char *argv[])
{
	
	
	
	
	int k = 3;
	
	vector<Node*> swapNodes;
	vector<Node*> swapNodesPredecessors;
	vector<int> swapNodesPosition;
	
	swapNodes.resize(k*2);
	swapNodesPredecessors.resize(k*2);
	swapNodesPosition.resize(k);
	
	
	
	/*
	vector<int> symbolArray;
	
	symbolArray.push_back(1);
	symbolArray.push_back(2);
	symbolArray.push_back(3);
	symbolArray.push_back(4);
	symbolArray.push_back(5);
	symbolArray.push_back(6);
	
	PermutationGenerator permutationGenerator(symbolArray);
	
	vector<int> actPermutation;
	
	int retValue = permutationGenerator.ReturnNextPermutation(actPermutation);
	
	while(retValue != 3)
	{
		for (unsigned int i = 0; i < actPermutation.size(); i++)
		{
			std::cout << actPermutation.at(i);	
		}
		std::cout << "\n";
		
		retValue = permutationGenerator.ReturnNextPermutation(actPermutation);
	}
	*/
	
	
	vector<vector<int>> validPermutations;
	
	GenerateAllValidSwaps(validPermutations, k);
	
	
	// vector<int> test1;
	// test1.push_back(1);
	// test1.push_back(3);
	// test1.push_back(2);
	// test1.push_back(4);
	// test1.push_back(5);
	// test1.push_back(6);

	
	// vector<int> test2;
	// test2.push_back(1);
	// test2.push_back(2);
	// test2.push_back(3);
	// test2.push_back(4);
	// test2.push_back(5);
	// test2.push_back(6);
	
	
	//std::cout << AreCircularSequencesRotationsOfEachOther(test1, test2) <<"\n";
	//std::cout << DoesCircularSequenceContainsSubsequence(test1, test2) <<"\n";
	//std::cout << DoesSequenceContainsRequiredConnections(test1) <<"\n";
	
	
	CircularLinkedList graph;
	
	graph.InsertNode(20,10);
	graph.InsertNode(40,10);
	graph.InsertNode(60,10);
	graph.InsertNode(80,20);
	graph.InsertNode(100,10);
	graph.InsertNode(120,30);
	graph.InsertNode(110,60);
	graph.InsertNode(80,50);
	graph.InsertNode(40,60);
	graph.InsertNode(10,60);
	
	graph.DisplayList();
	
	
	//----------------------------------------
	
	/*
	Node* startNode;
	Node* startNodePredecessor;
	
	graph.GetStartNode (&startNode, &startNodePredecessor);
	*/
	
	//graf musi mit zarucenou nejakou minimalni delku
	
	// do funkce
	for (int i; i < k; i++)
	{
		InitNestedLoop(&graph, swapNodes, swapNodesPredecessors, swapNodesPosition, i);
	}
	

	
	//generovani n-tic
	int currentLoopLevel = k-1;
	
	//pak prejmenovat
	bool endOfLoopFlag;
	bool lastCombination = false;
	int maxIndexForCurrentLoopLevel;
	
	
	// [20, 10]
// [40, 10]
// [60, 10]
// [80, 20]
// [100, 10]
// [120, 30]
// [110, 60]
// [80, 50]
// [40, 60]
// [10, 60]

			
	
	
	
	//projdeme vsechny kombinace hran v grafu
	//tohle realizuje provedeni neurciteho poctu zanorenych cyklu podle parametru k (5-opt => 5 zanorenych cyklu v sobe)
	while (true)
	{	
		//pro kazdou kombinaci zkusime vsechny prohozy, pokud nejaky neni lepsi
		TryAllSwapsForCurrentEdgeCombination (swapNodes, swapNodesPredecessors, validPermutations);

		//ted musime najit dalsi kombinaci
        while (true)
		{
			//posuneme hranu v aktualne zanorenem cyklu na dalsi pozici v grafu
			graph.GetNextNode(&(swapNodes.at(currentLoopLevel*2)), &(swapNodesPredecessors.at(currentLoopLevel*2)));
			graph.GetNextNode(&(swapNodes.at(currentLoopLevel*2+1)), &(swapNodesPredecessors.at(currentLoopLevel*2+1)));
			//udrzujeme si pro kazdou hranu jeji vzdalenost(pocet hran) od startu, aby jsme pak mohly cykly korektne ukoncit
			swapNodesPosition.at(currentLoopLevel)++;

			//ted musime vyresit, jestli se doslo na konec aktualniho cyklu
			endOfLoopFlag = false;
			
			//zalezi na tom, jestli prvni hrana je nebo neni v pocatecni pozici,
			//protoze mezi hranami co se budou prohazovat musi byt mezera, takze jakmile se pocatecni hrana posune,
			//tak muzeme pouzit hranu ohranicenou predposlednim a poslednim vrcholem
			
			//maximalni index se vypocita tak, ze vezmeme delku grafu a od ni odecteme pocet pozic od konce podle urovne cyklu
			//nejvnorenejsi cyklus ma nejvyssi hodnotu a na rozdil od k se pocitaji od 0, tedy k-1-currentLoopLevel
			//tento pocet hran od konce pak musime vynasobit dvema, protoze mezi nimi musi byt alespon jedna hrana, ktera tvori mezeru
			maxIndexForCurrentLoopLevel = graph.GetLength()-(2*(k-1-currentLoopLevel));
			
			//je v pocatecni pozici
			if (swapNodesPosition.at(0) == 0)
			{
				//tedy v tomto pripade se graf jevi jako o 1 kratsi
				//pokud se aktualni index nevejde do limitu, tak jsme na konci a musime provest reset
				if (!(swapNodesPosition.at(currentLoopLevel) < maxIndexForCurrentLoopLevel-1))
				{
					endOfLoopFlag = true;   
				}

			}
			//neni v pocatecni pozici
			else
			{
				if (!(swapNodesPosition.at(currentLoopLevel) < maxIndexForCurrentLoopLevel))
				{
					endOfLoopFlag = true;   
				}
			}
			
			
			//provedeme reset
			if (endOfLoopFlag == true)
			{
				//pokud musime resetovat nejvyssi cyklus, prosli jsme vsechny kombinace a koncime
				if (currentLoopLevel == 0)
				{
					lastCombination = true;
					break;
				}
				
				//presuneme se na mene zanoreny cyklus dekrementaci hodnoty currentLoopLevel
				currentLoopLevel--;
			}
			//neprovedeme reset
			else
			{
				//pokud nejsme na konci a jsme v nejvice zanorenem cyklu, tak je vsechno v pohode a normalne vracime kombinaci
				if (currentLoopLevel != k-1)
			    {
					//protoze jsme se mohli dostat na konec vice cyklu soucasne, musime se ted postupne zanorovat dokud nedojdeme
					//do nejvice zanoreneho cyklu a pritom korektne inicializujeme cykly na danny stav
			        while (currentLoopLevel < k-1)
					{
						InitNestedLoop(&graph, swapNodes, swapNodesPredecessors, swapNodesPosition, currentLoopLevel+1);
						currentLoopLevel++;
					}
			    }
				
				break;
			}
		}
		
		//jednalo se o posledni kombinaci - koncime
		if (lastCombination == true)
		{
			break;
		}
		
	}

	
	
	
	
	
	
	
	return 0;
}









